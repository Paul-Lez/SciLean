import SciLean.Core.Defs
import SciLean.Core.Meta.RewriteBy
import SciLean.Core.AdjDiff
import SciLean.Core.Tactic.FunctionTransformation.Core
import SciLean.Core.UnsafeAD
import SciLean.Core.CoreFunctions
import SciLean.Data.DataArray

import SciLean.Physics.Shape

namespace SciLean

namespace Shape

-- A great inspiration for this file is this amazing argicle on basic shapes and
-- their distance function: https://iquilezles.org/articles/distfunctions/

------------------------------------------------------------------------------
-- Axis Aligned Box
------------------------------------------------------------------------------

structure AxisAlignedBoxAtOrigin.Params (X) {Œπ : Type} {_:Enumtype Œπ} [FinVec X Œπ] where
  radius : ‚Ñù^Œπ
  radius_valid : ‚àÄ i, 0 ‚â§ radius[i] -- we do not want empty box

def AxisAlignedBoxAtOrigin.toSet {X Œπ : Type} [Enumtype Œπ] [FinVec X Œπ] (p : Params X) (x : X) : Prop :=
  ‚àÄ i : Œπ, (Real.abs (ùï° i x)) ‚â§ p.radius[i]

abbrev AxisAlignedBoxAtOrigin (X : Type) {Œπ} {_ : Enumtype Œπ} [FinVec X Œπ] := Shape (AxisAlignedBoxAtOrigin.toSet (X:=X) (Œπ:=Œπ))

abbrev AxisAlignedBox (X : Type) {Œπ} {_:Enumtype Œπ} [FinVec X Œπ] := Shape (translatedSet (AxisAlignedBoxAtOrigin.toSet (X:=X) (Œπ:=Œπ)))

abbrev Box (X R : Type) {Œπ} {_:Enumtype Œπ} [FinVec X Œπ] [Group R] [LieGroup.SO R X]
  := Shape (rigidTransformSet R (AxisAlignedBoxAtOrigin.toSet (X:=X) (Œπ:=Œπ)))

def mkAxisAlignedBox {X : Type} {Œπ} {_:Enumtype Œπ} [FinVec X Œπ] (min max : X)
  : AxisAlignedBox X :=
  let p : AxisAlignedBoxAtOrigin.Params X :=
    {
      radius := ‚äû i, (0.5 : ‚Ñù) * (ùï° i max - ùï° i min).abs
      radius_valid := sorry
    }
  ‚ü®p, (0.5 : ‚Ñù) ‚Ä¢ (min + max)‚ü©

namespace AxisAlignedBoxAtOrigin

  variable {X Œπ} [Enumtype Œπ] [FinVec X Œπ]

  instance : HasLocate (toSet (X:=X) (Œπ:=Œπ)) where
    locate := Œª s x => Id.run do
      let mut l : Location := .inside
      for (i,_) in Enumtype.fullRange Œπ do
        let xi := (ùï° i x).abs
        if s.params.radius[i] < xi then
          return .outside
        if xi = s.params.radius[i] then
          l := .boundary
      return l
    is_locate := sorry

  instance [OrthonormalBasis X Œπ ‚Ñù] : HasSdf (toSet (X:=X) (Œπ:=Œπ)) where
    sdf := Œª s x => Id.run do
      let mut cornerDist : ‚Ñù := 0
      let mut sideDist   : ‚Ñù := 0
      for (i,id) in Enumtype.fullRange Œπ do
        let xi := ùï° i x
        let ri := s.params.radius[i]
        let q := xi.abs - ri

        -- initialize sideDist
        if id.1 = 0 then
          sideDist := q

        if q > 0 then
          cornerDist += q*q

        if sideDist < q then
          sideDist := q

      return cornerDist.sqrt + sideDist.min 0
    is_sdf := sorry

  instance : HasReflect (toSet (X:=X) (Œπ:=Œπ)) where
    trans := Œª p => p
    is_trans := sorry

  instance : HasScale (toSet (X:=X) (Œπ:=Œπ)) := Œª s =>
  {
    trans := Œª ‚ü®p, h‚ü© =>
      {
        radius := ‚äû i, s.abs * p[i]
        radius_valid := sorry
      }
    is_trans := sorry
  }

end AxisAlignedBoxAtOrigin


------------------------------------------------------------------------------
-- Ball
------------------------------------------------------------------------------

structure BallAtOrigin.Params (X : Type) [Hilbert X] where
  radius : ‚Ñù
  radius_valid : 0 ‚â§ radius

namespace BallAtOrigin.Params

  variable {X : Type} [Hilbert X] (p : Params X)

  def sdf (x : X) := ‚Äñx‚Äñ - p.radius

  def sdfGrad (x : X) := (‚àá (sdf p) x)
    rewrite_by
      unfold sdf; unfold gradient
      unsafe_ad
      fun_trans

  def sdfHess (x : X) (u v : X) := (‚àÇ (‚àÇ (sdf p)) x u v)
    rewrite_by
      unfold sdf; unfold gradient
      unsafe_ad
      fun_trans
      simp[fun_trans]
      fun_trans

  def levelSet (x : X) := ‚Äñx‚Äñ¬≤ - p.radius^2

  def levelSetGrad (x : X) := (‚àá (levelSet p) x)
    rewrite_by
      unfold levelSet; unfold gradient
      fun_trans

  def levelSetHess (x u v: X) := (‚àÇ (‚àÇ (levelSet p)) x u v)
    rewrite_by
      unfold levelSet; unfold gradient
      fun_trans; simp; fun_trans

end BallAtOrigin.Params

def BallAtOrigin.toSet {X} [Hilbert X] (p : Params X) (x : X) : Prop :=
  ‚Äñx‚Äñ ‚â§ p.radius

abbrev BallAtOrigin (X : Type) {Œπ : Type} {_ : Enumtype Œπ} [FinVec X Œπ] := Shape (BallAtOrigin.toSet (X:=X))

def mkBallAtOrigin (X) {Œπ} {_:Enumtype Œπ} [FinVec X Œπ] (radius : ‚Ñù)
  : BallAtOrigin X := ‚ü®radius.abs, sorry‚ü©

abbrev Ball (X) {Œπ} {_:Enumtype Œπ} [FinVec X Œπ] := Shape (translatedSet (BallAtOrigin.toSet (X:=X)))

def mkBall {X} {Œπ} {_:Enumtype Œπ} [FinVec X Œπ] (center : X) (radius : ‚Ñù)
  : Ball X := (mkBallAtOrigin X radius).mkTranslated center

namespace BallAtOrigin

  variable {X} [Hilbert X]

  instance : HasLevelSet (toSet (X:=X)) where
    levelSet := Œª s x => ‚Äñx‚Äñ¬≤ - s.params.radius^2
    is_level_set := sorry

  instance : HasLocate (toSet (X:=X)) := locateFromLevelSet

  instance : HasSdf (toSet (X:=X)) where
    sdf := Œª s x => ‚Äñx‚Äñ - s.params.radius
    is_sdf := sorry

  instance : HasReflect (toSet (X:=X)) where
    trans := Œª p => p
    is_trans := sorry

  instance (R : Type) [Group R] [LieGroup.SO R X] : HasRotate R (toSet (X:=X)) := Œª r =>
  {
    trans := Œª p => p
    is_trans := sorry
   }

  instance : HasScale (toSet (X:=X)) := Œª s =>
  {
    trans := Œª ‚ü®r, h‚ü© =>
      {
        radius := s.abs * r
        radius_valid := sorry
      }
    is_trans := sorry
  }

end BallAtOrigin


------------------------------------------------------------------------------
-- Capsule
------------------------------------------------------------------------------

structure Capsule.Params (X : Type) [Hilbert X] where
  point1 : X
  point2 : X
  radius : {r : ‚Ñù // 0 ‚â§ r}

def Capsule.sdf {X} [Hilbert X] (a b : X) (r : ‚Ñù) (x : X) : ‚Ñù :=
  let xa := x - a
  let ba := (b - a)
  let ba := (1/‚Äñba‚Äñ) ‚Ä¢ ba
  let h := ‚ü™xa, ba‚ü´.clamp 0 1
  ‚Äñxa - h‚Ä¢ba‚Äñ - r

def Capsule.toSet {X} [Hilbert X] (p : Params X) (x : X) : Prop :=
  Capsule.sdf p.point1 p.point2 p.radius x ‚â§ 0

abbrev Capsule (X Œπ : Type) [Enumtype Œπ] [FinVec X Œπ] := Shape (Capsule.toSet (X:=X))

namespace Capsule

  variable {X} [Hilbert X]

  instance : HasLevelSet (toSet (X:=X)) where
    levelSet := Œª s x =>
      let xa := x - s.params.point1
      let ba := (s.params.point2 - s.params.point1)
      let ba := (1/‚Äñba‚Äñ) ‚Ä¢ ba
      let h := ‚ü™xa, ba‚ü´.clamp 0 1
      ‚Äñxa - h‚Ä¢ba‚Äñ¬≤ - s.params.radius.1^2
    is_level_set := sorry

  instance : HasLocate (toSet (X:=X)) := locateFromLevelSet

  instance : HasSdf (toSet (X:=X)) where
    sdf := Œª s x =>
      let xa := x - s.params.point1
      let ba := (s.params.point2 - s.params.point1)
      let ba := (1/‚Äñba‚Äñ) ‚Ä¢ ba
      let h := ‚ü™xa, ba‚ü´.clamp 0 1
      ‚Äñxa - h‚Ä¢ba‚Äñ - s.params.radius
    is_sdf := sorry

  instance : HasReflect (toSet (X:=X)) where
    trans := Œª p =>
      {
        point1 := - p.point1
        point2 := - p.point2
        radius := p.radius
      }
    is_trans := sorry

  instance : HasTranslate (toSet (X:=X)) := Œª t =>
  {
    trans := Œª p =>
      {
        point1 := p.point1 + t
        point2 := p.point2 + t
        radius := p.radius
      }
    is_trans := sorry
   }

  instance (R : Type) [Group R] [LieGroup.SO R X] : HasRotate R (toSet (X:=X)) := Œª r =>
  {
    trans := Œª p =>
      {
        point1 := r ‚Ä¢ p.point1
        point2 := r ‚Ä¢ p.point2
        radius := p.radius
      }
    is_trans := sorry
   }


end Capsule


------------------------------------------------------------------------------
-- Round Cone
------------------------------------------------------------------------------



structure RoundCone.Params (X : Type) [Hilbert X] where
  a : X
  b : X
  r1 : ‚Ñù
  r2 : ‚Ñù
  valid : 0 ‚â§ r1 ‚àß 0 ‚â§ r2

namespace RoundCone.Params

  variable {X} [Hilbert X] (p : RoundCone.Params X)

  -- This code comes from https://iquilezles.org/articles/distfunctions/

  -- Maybe turn these into computed fields
  def ba := p.b - p.a
  def l2 := ‚Äñp.ba‚Äñ¬≤
  def rr := p.r1 - p.r2
  def a2 := p.l2 - p.rr^2
  def il2 := 1.0 / p.l2

  def sdf (x : X) :=
    let pa := x - p.a
    let y  := ‚ü™pa,p.ba‚ü´
    let z  := y - p.l2
    let x2 := ‚Äñp.l2‚Ä¢pa - y‚Ä¢p.ba‚Äñ¬≤
    let y2 := y*y*p.l2
    let z2 := z*z*p.l2

    let k := p.rr.sign*p.rr*p.rr*x2
    if (z.sign*p.a2*z2 > k) then
      (x2 + z2).sqrt * p.il2 - p.r2
    else if (y.sign*p.a2*y2 < k) then
      (x2 + y2).sqrt * p.il2 - p.r1
    else
    ((x2*p.a2*p.il2).sqrt+y*p.rr)*p.il2 - p.r1

  set_option synthInstance.maxSize 2000

  -- noncomputable
  -- def sdfGrad (x : X) := (‚àá p.sdf x)
  --   rewrite_by
  --     unfold sdf; unfold gradient
  --     unsafe_ad
  --     ignore_fun_prop
  --     fun_trans



end RoundCone.Params


def RoundCone.toSet {X} [Hilbert X] (p : Params X) (x : X) : Prop :=
  p.sdf x ‚â§ 0

abbrev RoundCone (X : Type) [Hilbert X] := Shape (RoundCone.toSet (X:=X))


namespace RoundCone

  variable {X} [Hilbert X]

  instance : HasSdf (toSet (X:=X)) where
    sdf := Œª s x => s.params.sdf x
    is_sdf := sorry

  instance : HasLocate (toSet (X:=X)) := locateFromSdf

  instance : HasReflect (toSet (X:=X)) where
    trans := Œª p =>
      {
        a := - p.a
        b := - p.b
        r1 := p.r1
        r2 := p.r2
        valid := p.valid
      }
    is_trans := sorry

  instance : HasTranslate (toSet (X:=X)) := Œª t =>
  {
    trans := Œª p =>
      {
        a := p.a + t
        b := p.b + t
        r1 := p.r1
        r2 := p.r2
        valid := p.valid
      }
    is_trans := sorry
   }

  instance (R : Type) [Group R] [LieGroup.SO R X] : HasRotate R (toSet (X:=X)) := Œª r =>
  {
    trans := Œª p =>
      {
        a := r ‚Ä¢ p.a
        b := r ‚Ä¢ p.b
        r1 := p.r1
        r2 := p.r2
        valid := p.valid
      }
    is_trans := sorry
   }

  instance : HasScale (toSet (X:=X)) := Œª s =>
  {
    trans := Œª p =>
      {
        a := s‚Ä¢p.a
        b := s‚Ä¢p.b
        r1 := s.abs*p.r1
        r2 := s.abs*p.r2
        valid := sorry
      }
    is_trans := sorry
   }

end RoundCone


variable {X Y} [SemiHilbert X] [SemiHilbert Y]
#check (‚àÇ‚Ä† Œª xy : X √ó Y => xy.fst) rewrite_by fun_trans [fun_trans]; simp [fun_trans]

open Lean Qq Meta

#eval show MetaM Unit from do

  let fst : Q(‚Ñù√ó‚Ñù ‚Üí ‚Ñù) := q(Œª xy : ‚Ñù √ó ‚Ñù => xy.fst)

  IO.println (‚Üê reduce fst)
