import SciLean.Core.Distribution.Basic
import SciLean.Core.FunctionTransformations
import SciLean.Core.FunctionPropositions
import SciLean.Core.Notation

set_option linter.unusedVariables false


open MeasureTheory

namespace SciLean

open Distribution

variable
  {R} [RealScalar R]
  {W} [Vec R W]
  {X} [Vec R X] [MeasureSpace X]
  {Y} [Vec R Y] [Module ‚Ñù Y]
  {Z} [Vec R Z] [Module ‚Ñù Z]
  {U} [Vec R U] -- [Module ‚Ñù U]
  {V} [Vec R V] -- [Module ‚Ñù U]


set_default_scalar R


noncomputable
def diracDeriv (x dx : X) : ùíü' X := fun œÜ ‚ä∏ cderiv R œÜ x dx

@[fun_prop]
def DistribDifferentiableAt (f : X ‚Üí ùíü'(Y,Z)) (x : X) :=
  ‚àÄ (œÜ : X ‚Üí ùíü Y), CDifferentiableAt R œÜ x ‚Üí CDifferentiableAt R (fun x => f x (œÜ x)) x


theorem distribDifferentiableAt_const_test_fun
    {f : X ‚Üí ùíü'(Y,Z)} {x : X}
    (hf : DistribDifferentiableAt f x)
    {œÜ : ùíü Y} :
    CDifferentiableAt R (fun x => f x œÜ) x := by
  apply hf
  fun_prop


@[fun_prop]
def DistribDifferentiable (f : X ‚Üí ùíü'(Y,Z)) :=
  ‚àÄ x, DistribDifferentiableAt f x


-- TODO:
-- probably change the definition of `parDistribDeriv` to:
-- ‚ü®‚ü®fun œÜ =>
--    if h : DistribDifferentiableAt f x then
--      ‚àÇ (x':=x;dx), ‚ü™f x', œÜ‚ü´
--    else
--      0 , sorry_proof‚ü©‚ü©
-- I believe in that case the function is indeed linear in œÜ

open Classical in
@[fun_trans]
noncomputable
def parDistribDeriv (f : X ‚Üí ùíü'(Y,Z)) (x dx : X) : ùíü'(Y,Z) :=
  ‚ü®fun œÜ => ‚àÇ (x':=x;dx), f x' œÜ, sorry_proof‚ü©


@[simp, ftrans_simp]
theorem action_parDistribDeriv (f : X ‚Üí ùíü'(Y,Z)) (x dx : X) (œÜ : ùíü Y) :
    parDistribDeriv f x dx œÜ = ‚àÇ (x':=x;dx), f x' œÜ := rfl


----------------------------------------------------------------------------------------------------
-- Const rule --------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

@[fun_prop]
theorem DistribDiffrentiable.const_rule (T : ùíü'(X,Y)) :
    DistribDifferentiable (fun _ : W => T) := by
  intro _ œÜ hœÜ; simp; fun_prop

@[fun_trans]
theorem parDistribDeriv.const_rule (T : ùíü'(X,Y)) :
    parDistribDeriv (fun _ : W => T)
    =
    fun w dw =>
      0 := by
  funext w dw; ext œÜ
  unfold parDistribDeriv
  fun_trans


----------------------------------------------------------------------------------------------------
-- Pure --------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

@[fun_prop]
theorem dirac.arg_xy.DistribDiffrentiable_rule
    (x : W ‚Üí X) (hx : CDifferentiable R x) :
    DistribDifferentiable (R:=R) (fun w => dirac (x w))  := by
  intro x
  unfold DistribDifferentiableAt
  intro œÜ hœÜ
  simp [action_dirac, dirac]
  fun_prop


@[fun_trans]
theorem dirac.arg_x.parDistribDeriv_rule
    (x : W ‚Üí X) (hx : CDifferentiable R x) :
    parDistribDeriv (R:=R) (fun w => dirac (x w))
    =
    fun w dw =>
      let xdx := fwdDeriv R x w dw
      diracDeriv xdx.1 xdx.2 := by --= (dpure (R:=R) ydy.1 ydy.2) := by
  funext w dw; ext œÜ
  unfold parDistribDeriv dirac diracDeriv
  simp [pure, fwdDeriv, DistribDifferentiableAt]
  fun_trans


----------------------------------------------------------------------------------------------------
-- Composition -------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

@[fun_prop]
theorem DistribDiffrentiable.comp_rule
    (f : Y ‚Üí ùíü'(Z,U)) (g : X ‚Üí Y)
    (hf : DistribDifferentiable f) (hg : CDifferentiable R g) :
    DistribDifferentiable (fun x => f (g x)) := by
  intro x
  unfold DistribDifferentiableAt
  intro œÜ _
  apply CDifferentiable.comp_rule (K:=R) (f:=fun xy : X√óY => f xy.2 (œÜ xy.1)) (g:=fun x => (x, g x))
    (hg:=by fun_prop)
  intro x
  sorry_proof -- is this even true ?


@[fun_trans]
theorem parDistribDeriv.comp_rule
    (f : Y ‚Üí ùíü'(Z,U)) (g : X ‚Üí Y)
    (hf : DistribDifferentiable f) (hg : CDifferentiable R g) :
    parDistribDeriv (fun x => f (g x))
    =
    fun x dx =>
      let ydy := fwdDeriv R g x dx
      parDistribDeriv f ydy.1 ydy.2 := by

  funext x dx; ext œÜ
  unfold parDistribDeriv
  simp[hg]
  sorry_proof


----------------------------------------------------------------------------------------------------
-- Bind --------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------


-- The assumptions here are definitely not right!!!
-- I think `f` has to be `deg`
@[fun_prop]
theorem Bind.bind.arg_fx.DistribDifferentiable_rule
    (f : X ‚Üí Y ‚Üí ùíü'(Z,V)) (g : X ‚Üí ùíü'(Y,U)) (L : U ‚ä∏ V ‚ä∏ W)
    (hf : DistribDifferentiable (fun (x,y) => f x y)) -- `f` has to be nice enough to accomodate action of `g`
    (hg : DistribDifferentiable g) :
    DistribDifferentiable (fun x => (g x).bind (f x) L) := by

  intro x
  unfold DistribDifferentiableAt
  intro œÜ hœÜ
  simp
  sorry_proof


@[fun_trans]
theorem Bind.bind.arg_fx.parDistribDiff_rule
    (f : W ‚Üí X ‚Üí ùíü'(Y,V)) (g : W ‚Üí ùíü'(X,U)) (L : U ‚ä∏ V ‚ä∏ W)
    (hf : DistribDifferentiable (fun (w,x) => f w x)) -- `f` has to be nice enough to accomodate action of `g`
    (hg : DistribDifferentiable g) :
    parDistribDeriv (fun w => (g w).bind (f w) L)
    =
    fun w dw =>
      ((parDistribDeriv g w dw).bind (f x ¬∑ ) L)
      +
      ((g w).bind (fun x => parDistribDeriv (f ¬∑ x) w dw) L) := sorry_proof



----------------------------------------------------------------------------------------------------
-- Move these around -------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

@[fun_prop]
theorem Distribution.restrict.arg_T.IsSmoothLinearMap_rule (T : W ‚Üí ùíü'(X,Y)) (A : Set X)
    (hT : IsSmoothLinearMap R T) :
    IsSmoothLinearMap R (fun w => (T w).restrict A) := sorry_proof

@[fun_prop]
theorem Distribution.restrict.arg_T.IsSmoothLinearMap_rule_simple (A : Set X) :
    IsSmoothLinearMap R (fun (T : ùíü'(X,Y)) => T.restrict A) := sorry_proof


@[fun_trans]
theorem Distribution.restrict.arg_T.parDistribDeriv_rule (T : W ‚Üí ùíü'(X,Y)) (A : Set X)
    (hT : DistribDifferentiable T) :
    parDistribDeriv (fun w => (T w).restrict A)
    =
    fun w dw =>
      (parDistribDeriv T w dw).restrict A := sorry_proof

@[fun_prop]
theorem Function.toDistribution.arg_f.CDifferentiable_rule (f : W ‚Üí X ‚Üí Y)
    (hf : ‚àÄ x, CDifferentiable R (f ¬∑ x)) :
    CDifferentiable R (fun w => (fun x => f w x).toDistribution (R:=R)) := sorry_proof

@[fun_trans]
theorem Function.toDistribution.arg_f.cderiv_rule (f : W ‚Üí X ‚Üí Y)
    (hf : ‚àÄ x, CDifferentiable R (f ¬∑ x)) :
    cderiv R (fun w => (fun x => f w x).toDistribution (R:=R))
    =
    fun w dw =>
      (fun x =>
        let dy := cderiv R (f ¬∑ x) w dw
        dy).toDistribution := sorry_proof

@[fun_trans]
theorem toDistribution.linear_parDistribDeriv_rule (f : W ‚Üí X ‚Üí Y) (L : Y ‚Üí Z)
    (hL : IsSmoothLinearMap R L) :
    parDistribDeriv (fun w => (fun x => L (f w x)).toDistribution)
    =
    fun w dw =>
      parDistribDeriv (fun w => (fun x => f w x).toDistribution) w dw |>.postComp (fun y ‚ä∏ L y) := by
  funext w dw
  unfold parDistribDeriv Distribution.postComp Function.toDistribution
  ext œÜ
  simp [ftrans_simp] -- , Distribution.mk_extAction_simproc]
  sorry_proof



----------------------------------------------------------------------------------------------------
-- Integral ----------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------

variable [MeasureSpace X] [MeasureSpace Y] [MeasureSpace (X√óY)]

open Notation

@[fun_trans]
theorem cintegral.arg_f.cderiv_distrib_rule (f : W ‚Üí X ‚Üí Y) :
    cderiv R (fun w => ‚à´' x, f w x)
    =
    fun w dw =>
      (parDistribDeriv (fun w => (f w ¬∑).toDistribution) w dw).extAction (fun _ => (1:R)) (fun y ‚ä∏ fun r ‚ä∏ r ‚Ä¢ y) := sorry_proof


@[fun_trans]
theorem cintegral.arg_f.cderiv_distrib_rule' (f : W ‚Üí X ‚Üí R) (A : Set X):
    cderiv R (fun w => ‚à´' x in A, f w x)
    =
    fun w dw =>
       (parDistribDeriv (fun w => (f w ¬∑).toDistribution) w dw).restrict A |>.extAction (fun _ => (1:R)) (fun y ‚ä∏ fun r ‚ä∏ r ‚Ä¢ y) := sorry_proof


@[fun_trans]
theorem cintegral.arg_f.parDistribDeriv_rule (f : W ‚Üí X ‚Üí Y ‚Üí Z) :
    parDistribDeriv (fun w => (fun x => ‚à´' y, f w x y).toDistribution (R:=R))
    =
    fun w dw =>
      let Tf := (fun w => (fun x => (fun y => f w x y).toDistribution (R:=R)).toDistribution (R:=R))
      parDistribDeriv Tf w dw |>.postComp (fun T ‚ä∏ T.extAction (fun _ => (1:R)) (fun z ‚ä∏ fun r ‚ä∏ r ‚Ä¢ z)) := by
  funext w dw
  unfold parDistribDeriv postComp Function.toDistribution
  ext œÜ
  simp [ftrans_simp] -- , Distribution.mk_extAction_simproc]
  sorry_proof


@[fun_trans]
theorem cintegral.arg_f.parDistribDeriv_rule' (f : W ‚Üí X ‚Üí Y ‚Üí Z) (B : X ‚Üí Set Y) :
    parDistribDeriv (fun w => (fun x => ‚à´' y in B x, f w x y).toDistribution)
    =
    fun w dw =>
      let Tf := (fun w => (fun x => ((fun y => f w x y).toDistribution (R:=R)).restrict (B x)).toDistribution (R:=R))
      parDistribDeriv Tf w dw |>.postComp (fun T ‚ä∏ T.extAction (fun _ => (1:R)) (fun z ‚ä∏ fun r ‚ä∏ r ‚Ä¢ z)) := sorry_proof





----------------------------------------------------------------------------------------------------
-- Add ---------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------


@[fun_prop]
theorem HAdd.hAdd.arg_a0a1.DistribDifferentiable_rule (f g : W ‚Üí ùíü'(X,Y))
    (hf : DistribDifferentiable f) (hg : DistribDifferentiable g) :
    DistribDifferentiable (fun w => f w + g w) := sorry_proof


@[fun_trans]
theorem HAdd.hAdd.arg_a0a1.parDistribDeriv_rule (f g : W ‚Üí ùíü'(X,Y))
    (hf : DistribDifferentiable f) (hg : DistribDifferentiable g) :
    parDistribDeriv (fun w => f w + g w)
    =
    fun w dw =>
      let dy := parDistribDeriv f w dw
      let dz := parDistribDeriv g w dw
      dy + dz := sorry_proof


----------------------------------------------------------------------------------------------------
-- Sub ---------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------


@[fun_prop]
theorem HSub.hSub.arg_a0a1.DistribDifferentiable_rule (f g : W ‚Üí ùíü'(X,Y)) :
    -- (hf : DistribDifferentiable f) (hg : DistribDifferentiable g) :
    DistribDifferentiable (fun w => f w - g w) := sorry_proof


@[fun_trans]
theorem HSub.hSub.arg_a0a1.parDistribDeriv_rule (f g : W ‚Üí ùíü'(X,Y)) :
    -- (hf : DistribDifferentiable f) (hg : DistribDifferentiable g) :
    parDistribDeriv (fun w => f w - g w)
    =
    fun w dw =>
      let dy := parDistribDeriv f w dw
      let dz := parDistribDeriv g w dw
      dy - dz := sorry_proof




-- ----------------------------------------------------------------------------------------------------
-- -- Sub ---------------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------------------

-- @[fun_prop]
-- theorem HSub.hSub.arg_a0a1.DistribDifferentiable_rule (f g : W ‚Üí X ‚Üí Y)
--     /- (hf : ‚àÄ x, CDifferentiable R (f ¬∑ x)) (hg : ‚àÄ x, CDifferentiable R (g ¬∑ x)) -/ :
--     DistribDifferentiable (fun w => (fun x => f w x - g w x).toDistribution (R:=R)) := by
--   intro _ œÜ hœÜ; simp; sorry_proof -- fun_prop (disch:=assumption)


-- @[fun_trans]
-- theorem HSub.hSub.arg_a0a1.parDistribDeriv_rule (f g : W ‚Üí X ‚Üí Y)
--     /- (hf : ‚àÄ x, CDifferentiable R (f ¬∑ x)) (hg : ‚àÄ x, CDifferentiable R (g ¬∑ x)) -/ :
--     parDistribDeriv (fun w => (fun x => f w x - g w x).toDistribution)
--     =
--     fun w dw =>
--       parDistribDeriv (fun w => (f w ¬∑).toDistribution) w dw
--       -
--       parDistribDeriv (fun w => (g w ¬∑).toDistribution (R:=R)) w dw := by
--   funext w dw; ext œÜ; simp[parDistribDeriv]
--   sorry_proof


-- ----------------------------------------------------------------------------------------------------
-- -- Mul ---------------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------------------

-- @[fun_prop]
-- theorem HMul.hMul.arg_a0a1.DistribDifferentiable_rule (f : W ‚Üí X ‚Üí R) (r : R)
--     /- (hf : ‚àÄ x, CDifferentiable R (f ¬∑ x)) (hg : ‚àÄ x, CDifferentiable R (g ¬∑ x)) -/ :
--     DistribDifferentiable (fun w => (fun x => r * f w x).toDistribution (R:=R)) := by
--   intro _ œÜ hœÜ; simp; sorry_proof -- fun_prop (disch:=assumption)


-- @[fun_trans]
-- theorem HMul.hMul.arg_a0a1.parDistribDeriv_rule (f : W ‚Üí X ‚Üí R) (r : R)
--     /- (hf : ‚àÄ x, CDifferentiable R (f ¬∑ x)) (hg : ‚àÄ x, CDifferentiable R (g ¬∑ x)) -/ :
--     parDistribDeriv (fun w => (fun x => r * f w x).toDistribution)
--     =
--     fun w dw =>
--       r ‚Ä¢ (parDistribDeriv (fun w => (f w ¬∑).toDistribution (R:=R)) w dw) := by
--   funext w dw; ext œÜ; simp[parDistribDeriv]
--   sorry_proof


-- ----------------------------------------------------------------------------------------------------
-- -- Smul ---------------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------------------

-- @[fun_prop]
-- theorem HSMul.hSMul.arg_a0a1.DistribDifferentiable_rule (f : W ‚Üí X ‚Üí Y) (r : R)
--     /- (hf : ‚àÄ x, CDifferentiable R (f ¬∑ x)) (hg : ‚àÄ x, CDifferentiable R (g ¬∑ x)) -/ :
--     DistribDifferentiable (fun w => (fun x => r ‚Ä¢ f w x).toDistribution (R:=R)) := by
--   intro _ œÜ hœÜ; simp; sorry_proof -- fun_prop (disch:=assumption)


-- @[fun_trans]
-- theorem HSMul.hSMul.arg_a0a1.parDistribDeriv_rule (f : W ‚Üí X ‚Üí Y) (r : R)
--     /- (hf : ‚àÄ x, CDifferentiable R (f ¬∑ x)) (hg : ‚àÄ x, CDifferentiable R (g ¬∑ x)) -/ :
--     parDistribDeriv (fun w => (fun x => r ‚Ä¢ f w x).toDistribution)
--     =
--     fun w dw =>
--       r ‚Ä¢ (parDistribDeriv (fun w => (f w ¬∑).toDistribution (R:=R)) w dw) := by
--   funext w dw; ext œÜ; simp[parDistribDeriv]
--   sorry_proof



-- ----------------------------------------------------------------------------------------------------
-- -- Div ---------------------------------------------------------------------------------------------
-- ----------------------------------------------------------------------------------------------------

-- @[fun_prop]
-- theorem HDiv.hDiv.arg_a0a1.DistribDifferentiable_rule (f : W ‚Üí X ‚Üí R) (r : R)
--     /- (hf : ‚àÄ x, CDifferentiable R (f ¬∑ x)) (hg : ‚àÄ x, CDifferentiable R (g ¬∑ x)) -/ :
--     DistribDifferentiable (fun w => (fun x => f w x / r).toDistribution (R:=R)) := by
--   intro _ œÜ hœÜ; simp; sorry_proof -- fun_prop (disch:=assumption)


-- @[fun_trans]
-- theorem HDiv.hDiv.arg_a0a1.parDistribDeriv_rule (f : W ‚Üí X ‚Üí R) (r : R)
--     /- (hf : ‚àÄ x, CDifferentiable R (f ¬∑ x)) (hg : ‚àÄ x, CDifferentiable R (g ¬∑ x)) -/ :
--     parDistribDeriv (fun w => (fun x => f w x / r).toDistribution)
--     =
--     fun w dw =>
--       r‚Åª¬π ‚Ä¢ (parDistribDeriv (fun w => (f w ¬∑).toDistribution (R:=R)) w dw) := by
--   funext w dw; ext œÜ; simp[parDistribDeriv]
--   sorry_proof
